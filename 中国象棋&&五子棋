/*-----------------
实际写了1500行
这个游戏是第一次做大工程，其实语言可以更简练压缩到800行左右。
后续再改进。
----------------*/

#include<stdio.h>

#include<conio.h>

#include<string.h>

#include<stdlib.h>

#include<windows.h> 



int x,y,i,j,k,p,q,num = 1,round,place_x1 = 0,place_y1 = 0,place_x2 = 0,place_y2 = 0;              //象棋游戏的全局变量                                          //基本参数 

int check_x,check_y,check_turn;

char ch, turn = 'O',turn1 = 'N',temp,temp1;    	

char check_1[9][3] ={"车","马","象","士","将","炮","兵","+-"};  //取棋子时只判断前8合法， 

char check_2[9][3] ={"車","馬","相","仕","帥","砲","卒","+-"};	//下棋子时判断多一个空位合法 

char check[3];



void menu()             //主菜单 

{

	system("cls"); 

	system("mode con cols=40 lines=25");      //迷你界面 

    system("color 06");



	printf("\n\n[=====================================]\n");

	Sleep(100);

    printf("[[-----------------------------------]]\n");

    	Sleep(100);

    printf("[[       |                    |      ]]\n");

    	Sleep(100);



    printf("[[       |   【C语言小游戏】  |      ]]\n");

    	Sleep(100);

    printf("[[       |                    |      ]]\n");

    	Sleep(100);

    printf("[[       |    【菜单/nemu】   |      ]]\n");

    	Sleep(100);

    printf("[[       |                    |      ]]\n");

    	Sleep(100);

    printf("[[       |  ----------------  |      ]]\n");

    	Sleep(100);

    printf("[[       |  ① 双人单机象棋   |      ]]\n");

    	Sleep(100);

    printf("[[       |  ----------------  |      ]]\n");

    	Sleep(100);

    printf("[[       |  ②双人单机五子棋  |      ]]\n");

    	Sleep(100);

    printf("[[       |  ----------------  |      ]]\n");

    	Sleep(100);

    printf("[[       |  ③ 待开发的游戏   |      ]]\n");

    	Sleep(100);

    printf("[[       |  ----------------  |      ]]\n");

    	Sleep(100);

    printf("[[       |  ④   更多信息     |      ]]\n");

    	Sleep(100);

    printf("[[       |  ----------------  |      ]]\n");

    	Sleep(100);

    printf("[[       |  ⑤    退出        |      ]]\n");

    	Sleep(100);

    printf("[[       |  ----------------  |      ]]\n");

    	Sleep(100);

    printf("[[                                   ]]\n");

    	

    	Sleep(100);

	printf("[=====================================]\n");

		Sleep(200);

	printf("         <<按下相应数字进行选择>>\n");

    return;

}



void more()              //更多内容 

{

	system("cls"); 

	system("mode con cols=100 lines=30");      //迷你界面 

    system("color 66");

	printf("[[---------------------------------------------------------------------------]]\n");

    	Sleep(500);

    printf("[[       |                                                             |     ]]\n");

    	Sleep(500);

    printf("[[       |   author: llz           blog:https://404name.github.io      |     ]]\n");

    	Sleep(500); 

    printf("[[       |   创作历程：                                                |     ]]\n");

    	Sleep(500);

    printf("[[       |  ---------------------------------------------------------  |     ]]\n");

    	Sleep(500);

    printf("[[       |  1.小游戏《走迷宫》学会wasd控制移动                         |     ]]\n");

    	Sleep(500);

    printf("[[       |  -------------------------------------------------------    |     ]]\n");

    	Sleep(500);

    printf("[[       |  2.在其基础上制作了简易的五子棋                             |     ]]\n");

    	Sleep(500);

    printf("[[       |  --------------------------------------------------------   |     ]]\n");

    	Sleep(500);

    printf("[[       |  3.在制作五子棋过程中学会巧妙的用temp储存状态               |     ]]\n");

    	Sleep(500);

    printf("[[       |  让五子棋的二维数组都可以在动态稳定                         |     ]]\n");

    	Sleep(500);

    printf("[[       |  ---------------------------------------------------------  |     ]]\n");

    	Sleep(500);

    printf("[[       |  4.在五子棋基础上做象棋使2个字节的汉字也能同时移动实现取棋和杀棋  ]]\n");

    	Sleep(500);

    printf("[[       |  ---------------------------------------------------------  |     ]]\n");

    	Sleep(500);

    printf("[[       |  5.通过定义每一个棋子规则使规则完善                        |     ]]\n");

    printf("[[       |  ---------------------------------------------------------  |     ]]\n");

    	Sleep(500);

    printf("[[       |  6.最后参考图书馆管理系统制作了小游戏合集系统界面           |     ]]\n");

    printf("[=============================================================================]\n");

    	Sleep(100);

    printf("若有bug记得告诉下我，谢谢0.0\n"); 

    printf("任意键继续\n");

    getch();

     printf("[[       |  --------------------------------------------------------- |     ]]\n");

    	Sleep(500);

    printf("[[       |  游戏缺陷：                                                 |     ]]\n");

    	Sleep(500);

    printf("[[       |  -------------------------------------------------------    |     ]]\n");

    	Sleep(500);

    printf("[[       |  1.编程语言不够简练，代码太长不够精简                       |     ]]\n");

    	Sleep(500);

    printf("[[       |  --------------------------------------------------------   |     ]]\n");

    	Sleep(500);

    printf("[[       |  2.呈现游戏界面不能直白的分辨双方棋子                       |     ]]\n");

    	Sleep(500);

    printf("[[       |  --------------------------------------------------------   |     ]]\n");

    	Sleep(500);

    printf("[[       |  3.第一次做这类程序，许多游戏细节上未能处理好               |     ]]\n");                                 

    	Sleep(500);

    printf("[[       |  ---------------------------------------------------------  |     ]]\n");

    	Sleep(500);

    printf("[[       |  更多：https://404name.github.io                            |     ]]\n");                                 

    	Sleep(500);

    printf("[[       |  ---------------------------------------------------------  |     ]]\n");

    printf("按任意键返回");

	getch();

	return ; 	

}

void check_main1(char* temp,char* temp1,char* turn,char* turn1,int *num,int *if_return,char map[1000][1000])         //(象棋函数 判断 将方  下棋是否合法 

{

	check[0] = *temp;

	check[1] = *temp1;

	check[2] = '\0';

	char a,b;								

	for ( i = 0; i < 8; i++)        

	{

		if( strcmp(check_2[i],check) == 0)

		{	

			*temp = *turn;

			*temp1 = *turn1;

			*turn = 'O';

			*turn1 = 'N'; 

			if( i < 7){

				printf("帅方的%s被吃\n",check_2[i]);

				Sleep(500);

			}	

			*num = *num + 1;

			for( k = 4; k <= 8; k = k + 2)   //判断帥是否死亡 

			{

				for(j = 15; j <= 23; j= j+ 4)

				{

					if(map[k][j] == check_2[4][0]  && map[k][j+1] == check_2[4][1])

					{

						place_x2 = k;

						place_y2 = j;

						break;

					}

				}

				if( j <= 23)

					break;

		    }

			if( k == 10)

			{

				printf("帥 被将死  将方获得胜利\n");

				printf("按任意键返回菜单"); 

					getch();

					*if_return = 1; 

					return;

			}

			for( k = 18; k <= 22; k = k + 2)   //判断将是否死亡 

			{

				for(j = 15; j <= 23; j= j+ 4)

				{

					if(map[k][j] == check_1[4][0]  && map[k][j+1] == check_1[4][1])

					{

						place_x1 = k;

						place_y1 = j;

						break;

					}	

				}

				if( j <= 23)

					break;

			}

			if( k == 24)

				{

					printf("将方 被将死  帥方获得胜利\n");

					printf("按任意键返回菜单"); 

					getch(); 

					*if_return = 1; 

					return; 

				}

			if( place_y1 == place_y2)

			{

				for( k = place_x2 + 2; k <= place_x1 - 2; k = k +2)

				{

					if(map[k][place_y1] != '+')

					break;	

				}

				if( k == place_x1)

				{

					if(round == 1)

						printf(" 将方对将   帥方胜利");

					else if( round == 2)

						printf(" 帥方对将   将方胜利");

					printf("按任意键返回菜单"); 

					getch(); 

					*if_return = 1; 

					return;

				}   	

			}

			break; 

		}	

	}

	if( i == 8)

	{

		printf("不合法的走法\n");

		Sleep(500);

	} 	 

} 

void check_main2(char* temp,char* temp1,char* turn,char* turn1,int *num,int *if_return,char map[1000][1000]) //象棋函数 判断  帥方下棋是否合法 

{   

	check[0] = *temp;

	check[1] = *temp1;

	check[2] = '\0';

	char a,b;

	for ( i = 0; i < 8; i++)        

	{

		if( strcmp(check_1[i],check) == 0)

		{	

			*temp = *turn;

			*temp1 = *turn1;

			*turn = 'O';

			*turn1 = 'N'; 

			if( i < 7)

			{

				printf("将方的%s被吃",check_1[i]);

				Sleep(500);

			}	

		    *num = *num + 1; 

			for( k = 4; k <= 8; k = k + 2)   //判断帥是否死亡 

		    {

				for(j = 15; j <= 23; j= j+ 4)

				{

					if(map[k][j] == check_2[4][0]  && map[k][j+1] == check_2[4][1])

					{

						place_x2 = k;

						place_y2 = j;

						break;

					}

				}

				if( j <= 23)

					break;

			}

			if( k == 10)

			{

				printf("帥 被将死  将方获得胜利\n");

				printf("按任意键返回菜单"); 

					getch();

					*if_return = 1; 

					return; 

			}

			for( k = 18; k <= 22; k = k + 2)   //判断将是否死亡 

			{

				for(j = 15; j <= 23; j= j+ 4)

				{

					if(map[k][j] == check_1[4][0]  && map[k][j+1] == check_1[4][1])

					{

						place_x1 = k;

						place_y1 = j;

						break;

					}	

				}

				if( j <= 23)

					break;

			}

			if( k == 24)

				{

					printf("将方 被将死  帥方获得胜利\n");

					printf("按任意键返回菜单"); 

					getch(); 

					*if_return = 1; 

					return;

				}

			if( place_y1 == place_y2)

			{

				for( k = place_x2 + 2; k <= place_x1 - 2; k = k +2)

				{

					if(map[k][place_y1] != '+')

						break;	

				}

				if( k == place_x1)

				{

					if(round == 1)

						printf(" 将方对将   帥方胜利");

					else if( round == 2)

						printf(" 帥方对将   将方胜利");

					printf("按任意键返回菜单"); 

					getch();

					*if_return = 1;  

					return;

				}   	

			} 

			break; 

		}	

	}

	if( i == 8)

	{

	printf("不合法的走法\n");

	Sleep(500);

	} 	 

}



void xiangqi()    //象棋主程序 

{

	char map[1000][1000]= {  "[[===================================]]",

                             "[|①将         【|象棋|】        ②帥|]",

                             "[====================================]]",

                             "[[-----------------------------------]]",

                             "[[ 車—馬—相—仕—帥—仕—相—馬—車]]", 

                             "[[ |   |   |   | \\ | / |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-]]",                            

                             "[[ |   |   |   | / | \\ |   |   |   | ]]",                           

                             "[[ +-—砲—+-—+-—+-—+-—+-—砲—+-]]",

                             "[[ |   |   |   |   |   |   |   |   | ]]",

                             "[[ 卒—+-—卒—+-—卒—+-—卒—+-—卒]]",

                             "[[ |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[===================================]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   | ]]",

                             "[[ 兵—+-—兵—+-—兵—+-—兵—+-—兵]]",

                             "[[ |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—炮—+-—+-—+-—+-—+-—炮—+-]]",

                             "[[ |   |   |   | \\ | / |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   | / | \\ |   |   |   | ]]",

                             "[[ 车—马—象—士—将—士—象—马—车]]",

                             "[[-----------------------------------]]",

                             "[=====================================]"};

	int if_return = 0;

	system("mode con cols=40 lines=30");      //迷你界面 

    system("color 70");

    printf("[====================================]\n");

    printf("[[----------------------------------]]\n");

    printf("[[ |                              | ]]\n");

    printf("[[ |       【<<游戏规则>>】       | ]]\n");

    printf("[[ |                              | ]]\n");

    printf("[[ |------------------------------| ]]\n");

    printf("[[ |  控制wasd双方轮流控制指针下棋| ]]\n");

    printf("[[ |------------------------------| ]]\n");

    printf("[[ |  键盘输入大小写 ' L '        | ]]\n");

    printf("[[ |  都视为确认下棋              | ]]\n");

    printf("[[ |------------------------------| ]]\n");

    printf("[[ |  为了方便区分棋子	          | ]]\n");

    printf("[[ |  后手方全设为繁体复杂字体    | ]]\n");

    printf("[[ |------------------------------| ]]\n");

    printf("[[ |  Tip目前已实现所有象棋规则   | ]]\n");

    printf("[[ |  能检测出的bug都已解决       | ]]\n");

    printf("[[ |  若因过程存在未发现bug见谅   | ]]\n");

    printf("[[ |------------------------------| ]]\n");

    printf("[[ |------------------------------| ]]\n");

    printf("[[ |  我已阅读规则，按任意键继续  | ]]\n");

    printf("[[ |------------------------------| ]]\n");

	printf("[===================================]\n");

	getch();

	system("mode con cols=40 lines=30");      //迷你界面 

    system("color 70"); 				

	for ( i = 0; i < 27; i++)

	{

			puts(map[i]);

			Sleep(100);

	}



	x = 6,y = 19;

    temp = map[x][y];

	temp1 = map[x][y+1];     

    while(num)            

    {    

	if(num % 2 == 1 &&num / 2 % 2 == 0){

    	printf("现在是'将'的回合\n");

    	round = 1;

	}	

	else if( num %2 == 1){

		printf("现在轮到'帥'的回合了\n");

		round = 2;  	

	}               

    ch = getch();

    if ( ch == 's')         //下移 

    {

        if( map[x+1][y]!= '-')

        {

            map[x][y] =temp;

            map[x][y+1] = temp1;

            x = x + 2;

            temp = map[x][y];

            temp1 = map[x][y+1];

            map[x][y] = turn;

            map[x][y+1] = turn1;

        }

    }

    else if ( ch == 'a')    //左移 

    {

        if(map[x][y-1]!=' ')

        {

            map[x][y] =temp;

            map[x][y+1] = temp1;

            y = y - 4;

            temp = map[x][y];

            temp1 = map[x][y+1];

            map[x][y] = turn;

            map[x][y+1] = turn1;

        }

    }

    else if ( ch == 'w')    //上移 

    {

        if(  map[x-1][y]!= '-')

        {

            map[x][y] =temp;

            map[x][y+1] = temp1;

            x = x - 2;

            temp = map[x][y];

            temp1 = map[x][y+1];

            map[x][y] = turn;

            map[x][y+1] = turn1;

        }

    }

    else if ( ch == 'd')    //右移 

    {

        if(map[x][y+2]!=']')

        {

            map[x][y] =temp;

            map[x][y+1] = temp1;

            y = y + 4;

            temp = map[x][y];

            temp1 = map[x][y+1];

            map[x][y] = turn;

            map[x][y+1] = turn1;

        }

    }

        else if( ch == 'l' || ch =='L') 

        {

        	if(num % 2 == 1 && temp != '+' && temp1 != '-')   //取 

        	{

				check[0] = temp;

				check[1] = temp1;

				check[2] = '\0';

				if( round == 1)

				{

					for (  i = 0; i < 7; i++)           //将方 

					{

						if( strcmp(check_1[i],check) == 0)

						{

							turn = temp;

        					turn1 = temp1;

        					temp = '+';

        					temp1 = '-';  

							check_x = x;

							check_y = y;

							check_turn = 10 + i;  

							num++;    

							break; 

						}	

					}

					if( i == 7){

						printf("这不是你的棋子\n");

						Sleep(500);

					}

				 }

				else if( round == 2)

				{

					for ( i = 0; i < 7; i++)           //将方 

					{

						if( strcmp(check_2[i],check) == 0)

						{

							turn = temp;

        					turn1 = temp1;

        					temp = '+';

        					temp1 = '-';

							check_x = x;

							check_y = y;

							check_turn = 20 + i;   

							num++;    

							break; 

						}	

					}

					if( i == 7){

						printf("这不是你的棋子\n");

						Sleep(500);

					}

					

				} 

			}

			else if( num % 2 == 0)                 //放 

			{             

		/*char check_1[8][3] ={"车","马","象","士","将","炮","卒","+-"}; 

		char check_2[8][3] ={"俥","馬","相","仕","帥","軳","兵","+-"};*/ 

			/*

		中界 楚河上下坐标  12    15 

		*/     

		//  往下2  往又4 

				if( check_turn < 20)          //将方 

				{

					if( check_turn == 10) 				//车    的走法规范     完成 

					{

						if((x == check_x && y == check_y))

						{		

							

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

						}

						else if(  y == check_y  )

						{

							if( x > check_x)

							{

								for(j = check_x + 2; j < x;j = j + 2)

								{

									if(map[j][y] == '+');

									else

									{

									printf("不合法的下发\n");

									Sleep(500);

									break;

									}

								}

								if( j >= x)

								check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								} 

							if( x < check_x)

							{

								for(j = check_x - 2; j > x;j = j - 2)

								{

									if(map[j][y] == '+');

									else

									{

									printf("不合法的下发\n");

									Sleep(500);

									break;

									}

								}

								if( j <= x)

								check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								} 	

						}

							

						else if(  x == check_x  )

						{

							if( y > check_y)

							{

								for(j = check_y + 4; j < y;j = j + 4)

								{

									if(map[x][j] == '+');

									else

									{

									printf("不合法的下发\n");

									Sleep(500);

									break;

									}

								}

								if( j >= y)

								check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								} 

							if( y < check_y)

							{

								for(j = check_y - 4; j > y;j = j - 4)

								{

									if(map[x][j] == '+');

									else

									{

									printf("不合法的下发\n");

									Sleep(500);

									break;

									}

								}

								if( j <= y)

								check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								} 	

						}	

						else

						{

							printf("不合法的下法\n");

							Sleep(500);

						}

					}

					if( check_turn == 11) 				//马    的走法规范   ok 

					{

						if((x == check_x && y == check_y))

						{		

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

						}

							else if( (abs( x - check_x) == 2&& abs( y - check_y) == 8)&& map[check_x][(y+check_y)/2] =='+')

						{

							check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

						}

						else if( (abs( x - check_x) == 4&& abs( y - check_y) == 4)&& map[(x + check_x)/2][check_y] == '+' )

						{

							check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

						}

						else

						{

								printf("不合法的下法\n");

							Sleep(500);

						}

					}	

						if( check_turn == 12) 				//相    的走法规范     完成 

					{

						if((x == check_x && y == check_y))

							{		

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

							}

						else if( x >= 15 &&(abs(y - check_y) == 8 && abs(x - check_x) == 4))

							{

							

							 if((x == 22 && (y == 11 || y == 27))||(x == 18 && ( y == 3 || y == 19 || y == 35)) ||(x == 14 && (y == 11|| y ==27)))

							{		

								if( map[(x+check_x)/2][(y+check_y)/2] == '+')

									check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								else

								{

									printf("棋子卡住，不可执行");

									Sleep(500); 

								} 

							}

							else

							{

									printf("不合法的下法\n");

								Sleep(500);

							}

						}

						else

						{

							printf("不合法的下法\n");

							Sleep(500);

						}  

					}

						if( check_turn == 13) 				//士    的走法规范    ok 

					{

						if((x == check_x && y == check_y))

						{		

							

						temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

						}

						else if( abs(x - check_x)== 2 && abs( y - check_y) == 4 &&((x==22 && (y == 15 || y == 23)) || ( x == 20 && y == 19) || ( x == 18 && ( y == 15 || y == 23))))

						{

							check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

						}

						else

						{

								printf("不合法的下法\n");

							Sleep(500);

						}

					}

						if( check_turn == 14) 				//将    的走法规范 

					{

						if((x == check_x && y == check_y))

						{		

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

						}

					else if( ((abs(x - check_x)== 2 && abs( y - check_y) == 0 )|| (abs(x - check_x)== 0 && abs( y - check_y) == 4)) && x >= 18 && x <= 22 && y >= 15 && y <= 23 )

						{

							check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

						}

						else

						{

								printf("不合法的下法\n");

							Sleep(500);

						}

					}

						if( check_turn == 15) 				//炮    的走法规范 

					{

						if((x == check_x && y == check_y))

						{		

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

						}

						else if( y == check_y )

						{

							int check_pao = 0;

							if( x > check_x)

							{

								for(j = check_x + 2; j<= x ;j = j+ 2)

								{

									if(map[j][y] == '+' );

									else									

										check_pao++;

								}

								if(check_pao == 1&& temp == '+')       //  直线行走但不可吃棋子 

									check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								else if( check_pao == 2 && temp != '+')      //跳跃吃棋 

									check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map); 

								else

								{

									printf("不合法的下法\n");

									Sleep(500);

								}

							}

							else

							{

								for(j = check_x - 2; j>= x;j = j - 2)

								{

									if(map[j][y] == '+' );

									else

									{

										check_pao++;

									}

								}

								if(check_pao == 1&& temp == '+')       //  直线行走但不可吃棋子 

									check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								else if( check_pao == 2 && temp != '+')      //跳跃吃棋 

									check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map); 

								else

								{

									printf("不合法的下法\n");

									Sleep(500);

								}

							}

						}

						else if( x == check_x )

						{

								int check_pao = 0;

							if( y > check_y)

							{

								for(j = check_y + 4; j<= y ;j = j+4)

								{

									if(map[x][j] == '+' );

									else									

										check_pao++;

								}

								if(check_pao == 1&& temp == '+')       //  直线行走但不可吃棋子 

									check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								else if( check_pao == 2 && temp != '+')      //跳跃吃棋 

									check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map); 

								else

								{

									printf("不合法的下法\n");

									Sleep(500);

								}

							}

							else

							{

								for(j = check_y - 4; j>= y;j = j - 4)

								{

									if(map[x][j] == '+' );

									else

										check_pao++;

								}

								if(check_pao == 1&& temp == '+')       //  直线行走但不可吃棋子 

									check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								else if( check_pao == 2 && temp != '+')      //跳跃吃棋 

									check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map); 

								else

								{

									printf("不合法的下法\n");

									Sleep(500);

								}

							}

						}

						else

						{

								printf("不合法的下法\n");

							Sleep(500);

						}

					}	

					if( check_turn == 16) 				//卒    的走法规范     成功 

					{

						if( x >= 14){

							if((x == check_x && y == check_y))

							{		

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

							}

							else if( x == check_x - 2 && y == check_y)

								check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

							else

							{

								printf("不合法的下法\n");

								Sleep(500);

							}		

						}

						else{

							if((x == check_x && y == check_y))

							{		

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

							}

							else if((x - check_x == 0 && abs(y-check_y) ==4) ||( x - check_x == -2 && abs(y-check_y) == 0))

								check_main1(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

							else

							{

							printf("不合法的下法\n");

							Sleep(500);

							}	

						}

					}		

				}

				

				

				

				else						   //帅方 

				{ 

					if( check_turn == 20) 				//车    的走法规范       完成 

					{ 

						if((x == check_x && y == check_y))

						{		

							

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

						}

						else if(  y == check_y  )

						{

							if( x > check_x)

							{

								for(j = check_x + 2; j < x;j = j + 2)

								{

									if(map[j][y] == '+');

									else

									{

									printf("不合法的下发\n");

									Sleep(500);

									break;

									}

								}

								if( j >= x)

								check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								} 

							if( x < check_x)

							{

								for(j = check_x - 2; j > x;j = j - 2)

								{

									if(map[j][y] == '+');

									else

									{

									printf("不合法的下发\n");

									Sleep(500);

									break;

									}

								}

								if( j <= x)

								check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								} 	

						}

							

						else if(  x == check_x  )

						{

							if( y > check_y)

							{

								for(j = check_y + 4; j < y;j = j + 4)

								{

									if(map[x][j] == '+');

									else

									{

									printf("不合法的下发\n");

									Sleep(500);

									break;

									}

								}

								if( j >= y)

								check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								} 

							if( y < check_y)

							{

								for(j = check_y - 4; j > y;j = j - 4)

								{

									if(map[x][j] == '+');

									else

									{

									printf("不合法的下发\n");

									Sleep(500);

									break;

									}

								}

								if( j <= y)

								check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								} 	

						}	

						else

						{

							printf("不合法的下法\n");

							Sleep(500);

						}

					}

					if( check_turn == 21) 				//马    的走法规范   ok 

					{

						if((x == check_x && y == check_y))

						{		

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

						}

							else if( (abs( x - check_x) == 2&& abs( y - check_y) == 8)&& map[check_x][(y+check_y)/2] =='+')

						{

							check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

						}

						else if( (abs( x - check_x) == 4&& abs( y - check_y) == 4)&& map[(x + check_x)/2][check_y] == '+' )

						{

							check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

						}

						else

						{

								printf("不合法的下法\n");

							Sleep(500);

						}

					}	

						if( check_turn == 22) 				//相    的走法规范    完成 

					{

						if((x == check_x && y == check_y))

							{		

						temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

							}

						else if( x <= 12 && (abs(y - check_y) == 8 && abs(x - check_x) == 4))

						{

							

							if((x == 4 && (y == 11 || y == 27))||(x == 8 && ( y == 3 || y == 19 || y == 35)) ||(x == 12 && (y == 11|| y ==27)))

							{		

								if( map[(x+check_x)/2][(y+check_y)/2] == '+')

									check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								else

								{

									printf("棋子卡住，不可执行");

									Sleep(500); 

								} 

							}

							else

							{

									printf("不合法的下法\n");

								Sleep(500);

							}

						}

						else

						{

							printf("不合法的下法\n");

							Sleep(500);

						}  

					}

						if( check_turn == 23) 				//士    的走法规范   ok 

					{

						if((x == check_x && y == check_y))

						{		

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

						}

						else if( abs(x - check_x)== 2 && abs( y - check_y) == 4 &&((x==4 && (y == 15 || y == 23)) || ( x == 6 && y == 19) || ( x == 8 && ( y == 15 || y == 23))))

						{

							check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

						}

						else

						{

								printf("不合法的下法\n");

							Sleep(500);

						}

					}

						if( check_turn == 24) 				//将    的走法规范   ok

					{

						if((x == check_x && y == check_y))

						{		

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

						}

						else if( ((abs(x - check_x)== 2 && abs( y - check_y) == 0 )|| (abs(x - check_x)== 0 && abs( y - check_y) == 4)) && x >= 4 && x <= 8 && y >= 15 && y <= 23 )

						{

							check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

						}

						else

						{

								printf("不合法的下法\n");

							Sleep(500);

						}

					}

						

					if( check_turn == 25) 				//炮    的走法规范 

					{

						if((x == check_x && y == check_y))

						{		

							temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

						}

						else if( y == check_y )

						{

							int check_pao = 0;

							if( x > check_x)

							{

								for(j = check_x + 2; j<= x ;j = j+ 2)

								{

									if(map[j][y] == '+' );

									else									

										check_pao++;

								}

								if(check_pao == 1&& temp == '+')       //  直线行走但不可吃棋子 

									check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								else if( check_pao == 2 && temp != '+')      //跳跃吃棋 

									check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map); 

								else

								{

									printf("不合法的下法\n");

									Sleep(500);

								}

							}

							else

							{

								for(j = check_x - 2; j>= x;j = j - 2)

								{

									if(map[j][y] == '+' );

									else

									{

										check_pao++;

									}

								}

								if(check_pao == 1&& temp== '+')       //  直线行走但不可吃棋子 

									check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								else if( check_pao == 2 && temp != '+')      //跳跃吃棋 

									check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map); 

								else

								{

									printf("不合法的下法\n");

									Sleep(500);

								}

							}

						}

						else if( x == check_x )

						{

								int check_pao = 0;

							if( y > check_y)

							{

								for(j = check_y + 4; j<= y ;j = j+4)

								{

									if(map[x][j] == '+' );

									else									

										check_pao++;

								}

								if(check_pao == 1&& temp == '+')       //  直线行走但不可吃棋子 

									check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								else if( check_pao == 2 && temp != '+')      //跳跃吃棋 

									check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map); 

								else

								{

									printf("不合法的下法\n");

									Sleep(500);

								}

							}

							else

							{

								for(j = check_y - 4 ; j>= y;j = j - 4)

								{

									if(map[x][j] == '+' );

									else

										check_pao++;

								}

								if(check_pao ==1&& temp == '+')       //  直线行走但不可吃棋子 

									check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								else if( check_pao == 2&& temp != '+')      //跳跃吃棋 

									check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map); 

								else

								{

									printf("不合法的下法\n");

									Sleep(500);

								}

							}

						}

						else

						{

								printf("不合法的下法\n");

							Sleep(500);

						}

					}	

					if( check_turn == 26) 				//卒    的走法规范     成功 

					{

						if( x <= 12){

							if((x == check_x && y == check_y))

							{		

								temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

							}

							else if( x == check_x + 2 && y == check_y)

								check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

							else

							{

								printf("不合法的下法\n");

								Sleep(500);

							}		

						}

						else{

							if((x == check_x && y == check_y))

							{		

								temp = turn;

							temp1 = turn1;

							turn = 'O';

							turn1 = 'N';

							num--;

							printf("三思而后行\n");

							printf("还是你的回合"); 

							Sleep(500);

							}

								else if((x - check_x == 0 && abs(y-check_y) ==4) ||( x - check_x == 2 && abs(y-check_y) == 0))

									check_main2(&temp,&temp1,&turn,&turn1,&num,&if_return,map);

								else{

								printf("不合法的下法\n");

								Sleep(500);

								}	

						}

					}

				} 

			}

        }

        system("cls");

        if( if_return) return;

        for(i = 0; i < 27; i++)

        puts(map[i]);

        

    }

    Sleep(5000);

 }

 

void wuziqi()

{

   int x,y,i,p,q,num = 1,check;

    char ch, turn,temp;

    system("mode con cols=40 lines=30");      //迷你界面 

    system("color 30");

    printf("[====================================]\n");

    printf("[[----------------------------------]]\n");

    printf("[[ |                              | ]]\n");

    printf("[[ |       【<<游戏规则>>】       | ]]\n");

    printf("[[ |                              | ]]\n");

    printf("[[ |------------------------------| ]]\n");

    printf("[[ |  控制wasd双方轮流控制指针下棋| ]]\n");

    printf("[[ |  游戏保证了棋子不会重叠      | ]]\n");

    printf("[[ |------------------------------| ]]\n");

    printf("[[ |  键盘输入大小写 ' L '        | ]]\n");

    printf("[[ |  都视为确认下棋              | ]]\n");

    printf("[[ |------------------------------| ]]\n");

    printf("[[ |  移动鼠标指针会覆盖原有棋子  | ]]\n");

    printf("[[ |  移开即恢复坐标原有状态      | ]]\n");

    printf("[[ |------------------------------| ]]\n");

    printf("[[ |------------------------------| ]]\n");

    printf("[[ |  我已阅读规则，按任意键继续  | ]]\n");

    printf("[[ |------------------------------| ]]\n");

	printf("[===================================]\n");

	getch();

	system("mode con cols=65 lines=43");      //迷你界面 

    system("color 30");

   char map[1000][1000]= {  "||===========================================================||",

                             "||   x                   ||欢乐五子棋||                 o    ||",

                             "||                       ==============                      ||",

                             "[=============================================================]",

                             "[[===========================================================]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[ |   |   |   |   |   |   |   |   |   |   |   |   |   |   | ]]",

                             "[[ +-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-—+-]]",

                             "[[===========================================================]]",

                             "[=============================================================]"

    };

    printf("游戏加载中ing\n将窗口上移以便获取下方信息\n"); 

	for(i = 0; i < 37; i++)

    {

		puts(map[i]);

		Sleep(100); 

	}

       

    

    x = 11,y = 19;

    temp = map[x][y];           //temp是关键：保存光标所指坐标上一次的状态 ，方便恢复与新建状态 



    while(num)                 //主程序：实现移动光标并指定坐标下棋 

    {                          //保证不出界，且保证已下棋位置不会再次被覆盖 

        if(num % 2 != 0){

        	turn = 'x';

			printf("轮到 %c 下了\n这是你的第 %d 步棋\n",turn,(num + 1) / 2); 

		}

        else{

        	turn = 'o';

        	printf("这是 %c 的回合\n这是你的第 %d 步棋\n",turn,num /2);

		} 

		if(num > 544)

			return;

		else if(num > 540)

		 	printf("有的惊喜就是在你也想不到的的情况下发生"); 

		else if( num > 500)

        	printf("填满有惊喜喔") ;

		else if( num > 200)

        	printf("你可以填满棋盘的"); 

		else if( num > 150)

        	printf("你眼睛不花吗") ;

		else if( num > 100)

        	printf("还没有分出胜负ne ") ;	

		else if( num > 80) 

        	printf("距离成功不远了") ; 

		else if( num > 50)

        	printf("看来你还能继续下") ;

		else if( num > 30)

        	printf("你还能清楚的看清棋盘吗？") ;

		

		

		else if( num > 20)

        	printf("快接近胜利了吗？\n") ;

		

		

	

		

        

         

		

		   

        ch = getch();

        if ( ch == 's')         //下移 

        {

            if( map[x+1][y]!= '=' &&map[x+1][y]!= '-')

            {

                map[x][y] = temp;

                x = x + 2;

                temp = map[x][y];

                map[x][y] = turn;

            }

        }

        else if ( ch == 'a')    //左移 

        {

            if( map[x][y-3]== '-' )

            {

                map[x][y] = temp;

                y = y - 4;

                temp = map[x][y];

                map[x][y] = turn;

            }

        }

        else if ( ch == 'w')    //上移 

        {

            if(  map[x-1][y]!= '=' && map[x-1][y]!= '-')

            {

                map[x][y] = temp;

                x = x - 2;

                temp = map[x][y];

                map[x][y] = turn;

            }

        }

        else if ( ch == 'd')    //右移 

        {

            if( map[x][y+5]== '-' )

            {

                map[x][y] =temp;

                y = y + 4;

                temp = map[x][y];

                map[x][y] = turn;

                

            }

        }

        else if( ch == 'l' || ch =='L')   //确认下棋后改变坐标状态，并且判断是否伍连。 

        {

            if(temp == '+')

            {

                map[x][y] = turn;

                temp = map[x][y];

                num++;

                

                

                check=1;                                //判断水平方向 

                {

                    p=x;

                    q=y;

                    q = q - 4;

                    

                    if( q >=0&& q<  62)

                    while(q >=0&& q< 62  &&  map[p][q]== turn)//防止数组下标越界

                    {

                    	check++;

                   		q = q - 4;

                    }  

                    p=x;

                    q=y;

                    q = q + 4;

                    

                    if( q >=0&& q< 62 )

                    while(q >=0&& q<  62 &&  map[p][q] == turn)//防止数组下标越界

                    {

                    	check++;

                    	q = q + 4;

                    } 

                    if(check  >= 5 ){

                    printf("%c win the game\n按任意键退出游戏",turn);

                    getch();

                    return ;}

                                                       

                }

                

                

                check=1;								//判断垂直方向 

                {

                    p=x;

                    q=y;

                    p = p - 2;

                    

                    if( p >=0&& p<= 37)

	                    while(p >=0&& p<= 37  &&  map[p][q]== turn)//防止数组下标越界

	                    {

	                    	check++;

	                   		p = p - 2;

	                    }  

                    p=x;

                    q=y;

                    p = p + 2;

                    

                    if( p >=0&& p<= 37 )

	                    while(p >=0&& p<=  37 &&  map[p][q] == turn)//防止数组下标越界

	                    {

	                    	check++;

	                    	p = p + 2;

	                    } 

	                if(check  >= 5 ){

	                printf("%c win the game\n多次按任意键退出游戏",turn);

	                getch();

	                getch();

					getch(); 

                    return;}

                }

                check=1;                                //判断左斜方向 

                {

                    p=x;

                    q=y;

                    q = q - 4;

                    p = p - 2; 

                    

                    if( q >=0&& q<  62 && p >=0 && p <= 37)

                    while(q >=0&& q<  62 && p >=0 && p <= 37 &&  map[p][q]== turn)//防止数组下标越界

                    {

                    	check++;

                   		q = q - 4;

                   		p = p - 2;;

                    }  

                    p=x;

                    q=y;

                    q = q + 4;

                    p = p + 2;

                    if( q >=0&& q<  62 && p >=0 && p <= 37 )

                    while(q >=0&& q<  62 && p >=0 && p <= 37 && map[p][q] == turn)//防止数组下标越界

                    {

                    	check++;

                    	q = q + 4;

                    	p = p + 2; 

                    } 

                    if(check  >= 5 ){

                    printf("%c win the game\n按任意键退出游戏",turn);

                    getch();

                      getch();

                        getch();

                    return;}

                    

                    check=1;                                //判断右斜方向 

                {

                    p=x;

                    q=y;

                    q = q + 4;

                    p = p - 2; 

                    

                    if( q >=0&& q<  62 && p >=0 && p <= 37)

                    while(q >=0&& q<  62 && p >=0 && p <= 37 &&  map[p][q]== turn)//防止数组下标越界

                    {

                    	check++;

                   		q= q + 4;

                   		p = p - 2;

                    }  

                    p=x;

                    q=y;

                    q = q - 4;

                    p = p + 2;

                    if( q >=0&& q<  62 && p >=0 && p <= 37 )

                    while(q >=0&& q<  62 && p >=0 && p <= 37 && map[p][q] == turn)//防止数组下标越界

                    {

                    	check++;

                    	q = q - 4;

                    	p = p + 2; 

                    } 

                    if(check  >= 5 ){

                    printf("%c win the game\n按任意键退出游戏",turn);

                    getch();

                    return;}

                                                       

                }                                    

                }

            }

            else if( temp =='o') {

                printf("此处不可以下棋！！\n");

                Sleep(500);

            }

            else if( temp =='x') {

                printf("此处不可以下棋！！\n");

                Sleep(500);

            }





        }

        system("cls");

        for(i = 0; i < 37; i++)

            puts(map[i]);

    }

}







int main()

{ 

	int choise;

    while(1)

    {

		menu();

		char choise;

		choise = getch();

        switch(choise)

        {

        case '1': xiangqi();break; 

        case '2': wuziqi();break;

        case '3': system("cls");printf("\n\n还在开发呢~~返回菜单\n\n");Sleep(1000);break;

        case '4': more();break; 

        case '5': {system("cls");

				printf("\n\n确定退出吗\n\n1.Yes    2.No\n");

				printf("\n( 1 / 2 )\n");

				char b;

				b = getch();

				if( b == '1') return 0;

				else if( b == '2') break; 

				else break;

		default: printf("请输入1 / 2确定是与否");Sleep(1000);break;

			}

        }

    }

}
